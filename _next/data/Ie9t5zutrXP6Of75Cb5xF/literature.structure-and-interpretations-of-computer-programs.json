{"pageProps":{"metadata":{"date":"\"2020-06-02 12:41:43 +08:00\"","date_modified":"\"2021-11-07 00:39:27 +08:00\"","language":"en","source":""},"title":"Structure and interpretation of computer programs","hast":{"type":"root","children":[{"type":"element","tagName":"nav","properties":{"className":"toc"},"children":[{"type":"element","tagName":"ol","properties":{"className":"toc-level toc-level-1"},"children":[{"type":"element","tagName":"li","data":{"hookArgs":[{"type":"element","tagName":"h1","properties":{"id":"elements-of-programming"},"children":[{"type":"text","value":"Elements of programming"}]}]},"properties":{"className":"toc-item toc-item-h1"},"children":[{"type":"element","tagName":"a","properties":{"className":"toc-link toc-link-h1","href":"/literature.structure-and-interpretations-of-computer-programs#elements-of-programming"},"children":[{"type":"text","value":"Elements of programming"}]}]},{"type":"element","tagName":"li","data":{"hookArgs":[{"type":"element","tagName":"h1","properties":{"id":"higher-order-functions"},"children":[{"type":"text","value":"Higher-order functions"}]}]},"properties":{"className":"toc-item toc-item-h1"},"children":[{"type":"element","tagName":"a","properties":{"className":"toc-link toc-link-h1","href":"/literature.structure-and-interpretations-of-computer-programs#higher-order-functions"},"children":[{"type":"text","value":"Higher-order functions"}]}]},{"type":"element","tagName":"li","data":{"hookArgs":[{"type":"element","tagName":"h1","properties":{"id":"data-abstractions"},"children":[{"type":"text","value":"Data abstractions"}]}]},"properties":{"className":"toc-item toc-item-h1"},"children":[{"type":"element","tagName":"a","properties":{"className":"toc-link toc-link-h1","href":"/literature.structure-and-interpretations-of-computer-programs#data-abstractions"},"children":[{"type":"text","value":"Data abstractions"}]}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This is just my personal notes on "},{"type":"element","tagName":"a","properties":{"href":"http://mitpress.mit.edu/sicp"},"children":[{"type":"text","value":"Structure and interpretation of computer programs"}]},{"type":"text","value":".\nI also studied with the "},{"type":"element","tagName":"a","properties":{"href":"https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter"},"children":[{"type":"text","value":"Brian Harvey's SICP lectures"}]},{"type":"text","value":" because I am a scrub. ;p\n"}]},{"type":"element","tagName":"h1","properties":{"id":"elements-of-programming"},"children":[{"type":"text","value":"Elements of programming"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Programming often requires the following:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Simple expressions with atomic value.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A way to combine procedures into complex expressions.\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A way to define procedures for abstractions of higher-level functions.\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In order to do programming, we must have a programming language.\nA programming language often requires the following to have an effective way of expressing code:\n"}]},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Expressions which varies from primitive expressions (e.g., "},{"type":"element","tagName":"code","properties":{"className":["inline-code"]},"children":[{"type":"text","value":"42"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["inline-code"]},"children":[{"type":"text","value":"1.683"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["inline-code"]},"children":[{"type":"text","value":"53819492184"}]},{"type":"text","value":") to compound expressions (e.g., "},{"type":"element","tagName":"code","properties":{"className":["inline-code"]},"children":[{"type":"text","value":"(+ 53 20)"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["inline-code"]},"children":[{"type":"text","value":"(- 464 254)"}]},{"type":"text","value":").\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"An environment of objects which you can refer by name either with values (e.g., "},{"type":"element","tagName":"code","properties":{"className":["inline-code"]},"children":[{"type":"text","value":"(define x 10)"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["inline-code"]},"children":[{"type":"text","value":"(define pi 3.14)"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["inline-code"]},"children":[{"type":"text","value":"(define e 2.71828)"}]},{"type":"text","value":") or procedures (e.g., "},{"type":"element","tagName":"code","properties":{"className":["inline-code"]},"children":[{"type":"text","value":"(define (square x) (* x x))"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["inline-code"]},"children":[{"type":"text","value":"(define (my-formula height weight length) (* 23 (/ height weight) (+ 3500 length)))"}]},{"type":"text","value":").\n"}]}]},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"An evaluation model for expressions since certain procedures can have different output from the order of operations.\n"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A programming language lets us abstract procedures as a black box.\nHere's an example of implementing the square root given a number.\n"}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-racket"]},"children":[{"type":"text","value":"(define (square x) (* x x))\n(define (improve guess x)\n  (/ (+ guess (/ x guess)) 2))\n\n(define (good-enough? guess x)\n  (< (abs (- (square guess) x)) 0.001))\n\n(define (sqrt-iter guess x)\n  (if (good-enough? guess x)\n      guess\n      (sqrt-iter (improve guess x) x)))\n\n(define (sqrt x)\n  (sqrt-iter 1.0 x))\n\n(sqrt 4)\n(sqrt 100)\n(sqrt 45.65)\n"}]}]},{"type":"element","tagName":"pre","properties":{"className":["fixed-width"]},"children":[{"type":"text","value":"2.0000000929222947\n10.000000000139897\n6.756478442187127"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\nIn order to do the square root extraction in our implementation, we define multiple procedures with each solving a part of the procedure: one procedure for indicating whether the guess is good enough, one for creating an improved guess for the next iteration, and one for actually doing the square root extraction.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"In general cases, we don't implement things as one thing as it will result in a messy state of code.\nInstead, we modularize those functions.\nWe classify these procedures as a "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"procedural abstraction"}]},{"type":"text","value":".\n"}]},{"type":"element","tagName":"h1","properties":{"id":"higher-order-functions"},"children":[{"type":"text","value":"Higher-order functions"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Functions and data are often separated similarly to verbs and subjects.\nWe tend to think of them as different things relying on each other to do things: functions need data to manipulate while data are raw information to be arranged by a function.\nHowever, the reality is that there is a blurry line to how distinct both of them are.\nFunctions can be treated similarly to data and vice versa.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The lesson of higher-order functions proves this.\nIt is one of the foundations of functional programming.\nIn order to learn about it, you need to know the key: "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"generalizing patterns"}]},{"type":"text","value":".\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"For example, say we have different functions for knowing the area of a shape.\n"}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-racket"]},"children":[{"type":"text","value":"(define pi 3.14)\n\n(define (square-area r) (* r r))\n(define (circle-area r) (* pi r r))\n(define (hexagon-area r) (* (sqrt 3) 1.5 r r))\n"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This could pass as a decent code if each area function is distinct from each other.\nHowever, all of the given area functions involves squaring the given parameter ("},{"type":"element","tagName":"code","properties":{"className":["inline-code"]},"children":[{"type":"text","value":"r"}]},{"type":"text","value":").\nWe can separate that step in a function like the following.\n"}]},{"type":"element","tagName":"pre","properties":{"className":["src-block"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-racket"]},"children":[{"type":"text","value":"(define pi 3.14)\n(define (area shape r) (* shape r r))\n\n(define square 1)\n(define circle pi)\n(define hexagon (* (sqrt 3) 1.5))\n\n;; We can then use it like this.\n;; Calcuating the area of square with a length of 4.\n(area square 4)\n\n;; Calculating the area of a circle with a radius of 10.\n(area circle 10)\n\n;; Calculating the area of a hexagon with length of 9.\n(area hexagon 9)\n"}]}]},{"type":"element","tagName":"h1","properties":{"id":"data-abstractions"},"children":[{"type":"text","value":"Data abstractions"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The idea behind data abstractions is to make procedures in a way that doesn't make assumptions to our data.\nTo make this possible, we have to separate the implementation of our data and the procedures that make use of that data.\n"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"One powerful way to start implementing abstract data is through wishful thinking — that is, assuming we already we have the components fully defined.\n"}]}]},"backlinks":[{"path":"/challenges.structure-and-interpretation-of-computer-programs","title":"Solutions: Structure and interpretation of computer programs"}]},"__N_SSG":true}